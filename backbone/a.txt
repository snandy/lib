Backbone.sync-将模型同步到服务器

1 sync方法把model持久化存储到服务器端，你可以重写该方法的实现方式，它默认使用jQuery的$.ajax。

2 整个Backbone，只有Model和Collection的sync会调用Backbone.sync。

3 请求类型由第一个参数method决定，可以是create/update/patch/delete/read。它默认采用RESTful请求。

4 请求的数据由第二个参数model决定，URL默认是model的url，数据是model的attributes转成JSON。数据类型默认是JSON类型。

5 请求后会触发model的request的事件，如果添加了该事件的handler后。


执行流程
1 处理type，从methodMap
2 初始化options
3 初始化params，含type/dataType/url
4 create/update/patch时，params的contentType为application/json，params.data确保有值，值为model转为json
5 emulateJSON
6 mimicking HTTP
7 非GET时， processData为false
8 PATCH时 IE低版本重写xhr
9 触发request事件


相关：
http://zh.wikipedia.org/wiki/REST
http://www.ruanyifeng.com/blog/2011/09/restful.html

下面详细说说

1 两个参数，都是对象类型，第一个扩展为原型方法，第二个扩展为类方法

var instanceObj = {
	name: '',
	getName: function() {},
	setName: function(name) {}
}
var classObj = {
	trim: function(str) {},
	mix: function() {}
}

// 生成一个新类CustomModel，它具有Backbone.Model的所有方法
var CustomModel = Backbone.Model.extend(instanceObj, classObj)

// instanceObj属性都拷贝到了CustomModel.prototype 上
_.each(['name','getName', 'setName'], function(attr) {
	console.log(attr in CustomModel.prototype)
})

// classObj属性都拷贝到了 CustomModel 上
_.each(['trim','mix'], function(attr) {
	console.log(attr in CustomModel)
})

2 参数中如果有constructor属性，那么最后就返回它，否则返回内部提供的child

这实际上告诉使用者可以自定义构造器，而不使用内部的child。
function MyConstructor(name, age) {
	this.name = name;
	this.age  = age;
}
var CustomModel = Backbone.Model.extend({
	constructor: MyConstructor,
	getName: function(){},
	setName: function(){}
})

var m1 = new CustomModel('John', 30)
console.log(m1.constructor === MyConstructor) // true

3 返回的类有个特殊属性 __super__，用它很方便的取得父类原型，进而取到父类构造器，最后在子类中去调用父类。类似于Java里的super关键字


function Person(name, age) {
	this.name = name
	this.age = age
}
Person.extend = Backbone.Model.extend // 把Backbone的extend拿出来用，O(∩_∩)O~

function ManConstructor(name, age) {
	ManConstructor.__super__.constructor.call(this, name, age)
	this.gender = 'male'
}
var Man = Person.extend({
	constructor: ManConstructor
})
var man = new Man('John', 30)
console.log(man) // ManConstructor { name="John", age=30, gender="male"}

关于这种用法的妙处，可以看看这篇文章 http://www.cnblogs.com/snandy/archive/2011/03/23/1992080.html


1 通过Model(View/Router等)的extend方法写类，产生的类直接继承了Model(View/Router等)
2 如果写的类不是Backbone提供的类，那么可以象3那样，把extend方法拿出来
3 

